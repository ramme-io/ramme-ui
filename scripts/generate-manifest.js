const fs = require('fs');
const path = require('path');
const doctrine = require('doctrine');

// Mapping singular categories to manifest keys
// UPDATED: Added mappings for your new architecture
const CATEGORY_MAP = {
  // --- Standard UI ---
  component: 'components',
  components: 'components',
  ui: 'components',
  input: 'components',
  form: 'components',
  feedback: 'components',
  navigation: 'components',
  'data-display': 'components',
  
  // --- Structure ---
  layout: 'layouts',
  layouts: 'layouts',
  
  // --- Business Logic (Blocks) ---
  // We map these to 'components' because to the AI, they are just bigger components.
  // Alternatively, you could add a new 'blocks' key to the manifest if you want strict separation.
  iot: 'components', 
  ai: 'components',
  blocks: 'components',

  // --- Logic/Utils ---
  util: 'utils',
  utils: 'utils',
  hook: 'hooks',
  hooks: 'hooks',
  data: 'data'
};

const getSourceFiles = (dir) => {
  let files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });
  for (const item of items) {
    const fullPath = path.join(dir, item.name);
    if (item.isDirectory()) {
      files = [...files, ...getSourceFiles(fullPath)];
    } else if (item.name.endsWith('.tsx') || item.name.endsWith('.ts')) {
      if (!item.name.endsWith('.test.tsx') && !item.name.endsWith('.stories.tsx')) {
        files.push(fullPath);
      }
    }
  }
  return files;
};

// Updated parseJsDoc to handle empty tags safely
const parseJsDoc = (content, filePath) => {
  const docRegex = /\/\*\*([\s\S]*?)\*\//g;
  const entries = [];
  let match;

  while ((match = docRegex.exec(content)) !== null) {
    const jsdoc = `/**${match[1]}*/`;
    const ast = doctrine.parse(jsdoc, { unwrap: true, sloppy: true });

    // Check if this block is a wizard block
    const isWizard = ast.tags.some(tag => tag.title === 'wizard');
    if (!isWizard) continue;

    console.log(`ðŸ” Found @wizard in: ${filePath}`);

    const entry = {
      name: '',
      description: ast.description || '',
      tags: [],
      category: '',
      props: [],
    };

    for (const tag of ast.tags) {
      // SAFETY FIX: Ensure description exists before using it
      const desc = tag.description || ''; 

      switch (tag.title) {
        case 'name':
          entry.name = tag.name || desc;
          break;
        case 'description':
          entry.description = desc;
          break;
        case 'tags':
          entry.tags = desc.split(',').map(t => t.trim()).filter(Boolean);
          break;
        case 'category':
          // Normalize category string for mapping
          entry.category = desc.toLowerCase().trim();
          break;
        case 'props':
          // SAFETY FIX: If desc is empty, skip splitting
          if (!desc) break;

          entry.props = desc
            .split(/(?:\r?\n|^)- /)
            .map(propStr => {
              if (!propStr.trim()) return null;
              const propLines = propStr.trim().split(/\r?\n/);
              const prop = {};
              propLines.forEach(line => {
                const separatorIndex = line.indexOf(':');
                if (separatorIndex === -1) return;
                const key = line.slice(0, separatorIndex).trim();
                const value = line.slice(separatorIndex + 1).trim();
                if (key && value) {
                  prop[key.replace(/^- /, '')] = value;
                }
              });
              return prop;
            }).filter(Boolean);
          break;
      }
    }

    if (entry.name) {
      console.log(`   âœ… Parsed: ${entry.name}`);
      entries.push(entry);
    }
  }

  return entries;
};

const buildManifest = () => {
  console.log('ðŸš€ Starting Manifest Generation...');
  
  const manifest = {
    components: [],
    layouts: [],
    utils: [],
    hooks: [],
    data: [],
  };

  const srcDir = path.resolve(__dirname, '../src');
  const files = getSourceFiles(srcDir);
  let totalEntries = 0;

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf-8');
    const filePath = path.relative(path.join(__dirname, '..'), file).replace(/\\\\/g, '/');
    const entries = parseJsDoc(content, filePath);

    for (const entry of entries) {
      entry.filePath = filePath;
      totalEntries++;

      // 3. MAP Category to Manifest Key
      // Use the map, default to 'components' if unknown
      const rawCat = entry.category ? entry.category : 'component';
      const manifestKey = CATEGORY_MAP[rawCat] || 'components';

      if (manifest[manifestKey]) {
        manifest[manifestKey].push(entry);
      } else {
        // Fallback safety
        manifest.components.push(entry);
      }
    }
  }

const manifestContent = `
// This file is auto-generated by scripts/generate-manifest.js
// Do not modify this file directly.

// UPDATED PATH: Point to the file you just created
import type { WizardManifest } from './src/lib/types/wizard';

export const wizardManifest: WizardManifest = ${JSON.stringify(manifest, null, 2)} as const;
`;

  fs.writeFileSync(path.resolve(__dirname, '../wizardManifest.ts'), manifestContent.trim());
  console.log(`\nâœ¨ Generated manifest with ${totalEntries} entries!`);
};

try {
  require('doctrine');
} catch (e) {
  console.error('Doctrine not found. Please run: pnpm add -D doctrine @types/doctrine');
  process.exit(1);
}

buildManifest();